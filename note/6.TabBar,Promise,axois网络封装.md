## 2. TabBar实现思路
1. 如果在下方有一个单独的TabBar组件 , 你如何封装
- 自定义TabBar组件 , 在APP中使用
- 让TabBar处于底部 , 并且设置相关的央视

2. TabBar中显示的内容由外界决定
- 定义插槽
- flex布局平分TabBar

3. 自定义TabBarItem , 可以传入 图片和文字
- 定义TabBarItem , 并且定义两个插槽 : 图片 , 文字.
- 给两个插槽外层包装div , 用于设置样式.
- 填充插槽 , 实现底部TabBar的效果

4. 传入 高亮图片
- 定义另外一个插槽 , 插入active-icon的数据
- 定义一个变量isActive , 通过 v-show 来决定是否显示对应的icon

5. TabBarItem绑定路由数据
- 安装路由 : npm install vue-router --save
- 完成router/index.js 的内容 , 以及创建对应的组件
- main.js中注册router
- APP中加入`<router-view>`组件

6. 点击item跳转到对应路由 , 并且动态决定isActive
- 监听item的点击, 通过this.$router.replace()替换路由路径
- 通过this.$route.path.indexOf(this.link) !== -1来判断是active

7. 动态计算active央视
- 封装新的计算属性 : this.isActive ? {'color': 'red'}:{}

## 2. Promise
### 2.1 什么是Promise呢
ES6中一个非常重要和好用的特性就是Promise
- 但是初次接触Peomise会一脸懵逼 , 这TM是什么东西 ?
- 看看官方或者一些文章对它的介绍和用法 , 也是一头雾水.

Promise到底是做什么的呢 ? 
- Promise是异步编程的一种解决方案.

那什么时候我们会来处理异步事件呢 ?
- 一种很常见的场景应该就是网络请求了.
- 我们封装一个网络请求的函数 , 因为不能立即拿到结果 , 所以不能像简单的3+4=7一样将结果返回
- 所以往往我们会传入另外一个函数 , 在数据请求成功时 , 将数据通过传入的函数回调出去.
- 如果只是一个简单的网络请求 , 那么这种方案不会给我们带来很大的麻烦.

但是 , 当网络请求非常复杂时 , 就会出现回调地狱.
- OK , 我以一个非常夸张的案例来说明.
### 2.2 网络请求的回调地狱
我们来考虑一个场景
- 我们需要通过一个url1从服务器加载一个数据data1 , data1中包含了下一个请求的url2
- 我们需要同各国data1取出url2 , 从服务器加载数据data2 , data2中包含了下一个请求的url3
- 我们需要通过data2取出url3 , 从服务器加载数据data3 , data3中包含了下一个请求的url4
- 发送网络请求url4 , 获取最终数据data4

如果通过回调一直获取 , 这样的代码难看而且不容易维护.
我们更加期望的是一种更加优雅的方式来进行这种异步操作.

Promise可以以一种非常优雅的方式来解决这个问题.
### 2.3 Promise三种状态
首先 , 当我们开发中有异步操作时 , 就可以给异步操作包装一个Promise
- 异步操作之后会有三种状态

我们一起来看一下这三种状态 :
- pending : 等待状态 , 比如正在进行网络请求 , 或者定时器没有到时间. 
- fulfill : 满足状态 , 当我们主动回调了resolve时 , 就处于该状态 , 并且会回调.then()
- reject : 拒绝状态 , 当我们主动回调了reject时 , 就处于该状态 , 并且会回调.catch()
## 3. Vuex
### 3.1 vuex是做什么的?
官方解释 : Vuex是一个专为Vue.js应用程序开发`状态管理模式`.
- 它采用集中式存储管理应用的所有组件的状态 , 并以相应的规则保证状态以一种可预测的方式发生变化.
- Vuex 也继承到Vue的官方调试工具devtools extension , 提供了诸如零配置的time-travel调试 , 状态快照导入导出等高级调试功能.

状态管理到底是什么?
- 状态管理模式 , 集中式存储管理这些名词听起来就非常高大赏 , 让人捉摸不透.
- 其实 , 你可以简单的将其看成把需要多个组件共享的变量全部存储在一个对象里面.
- 然后 , 将这个对象放在顶层的Vue实例中 , 让其他组件可以使用.
- 那么 , 多个组件是不是就可以共享这个对象中的所有变量属性了呢?

等等 , 如果是这样的话 , 为什么官方还要专门出一个插件Vuex呢?难道我们不能自己封装一个对象来管理吗?
- 当然可以 , 只是我们要先想想VueJS带给我们最大的便利是什么呢?没错,`就是响应式`

但是 , 有什么状态是需要我们在多个组件间共享的呢?
- 比如用户的登录状态 , 用户名称 , 头像 , 地理位置信息等等.
- 比如商品的收场 , 购物车中的物品等等.

## 4. 网络模块封装 axios
### 4.1 选择什么网络模型?
Vue中发送网络请求有非常多的方式 , 那么 , 在开发中 , 如果选择呢?

选择一: 传统的Ajax是基于XMLHttpRequest(XHR)
- 为什么不用它呢?
    - 非常好解释 , 配置和调用方式等非常混乱.
    - 编码起来看起来就非常蛋疼.
    - 所以真实开发中很少直接使用 , 而是使用jQuery-Ajax

选择二: 相对于传统的Ajax非常好用的jQuery-Ajax
- 为什么不用它呢?
    - 在Vue的整个开发中都是不需要使用jQuery了.
    - jQuery的代码1w+行
    - 完全没有必要为了用网络请求就引用这个重量级的框架.

选择三: Vue的1.x时 , 推出了Vue-resource
- 为什么不用它呢?
    - 在Vue2.0就没有更新维护了,作者表示退出了.

### 4.2 axios
功能提点:
- 在浏览器中发送 XMLHttpRequests 请求
- 在 node.js 中发送 http 请求
- 支持 Promise API
- 支持拦截请求和先工期球球
- 可以转换请求和响应数据.
- 支持多种请求方式
    - `axios(config)`
    - `axios.request(config)`
    - `axios.get(url[,config])`
    - `axios.delete(url[,config])`
    - `axios.head(url[,data[,config]])`
    - `axios.post(url[,[data,config]])`
    - `axios.put(url[,[data,config]])`
    - `axios.patch(url[,[data,config]])`

### 4.3 axios全局配置 为什么要进行封装
在上面的示例中 , 我们的BaseURL是固定的
- 事实上 , 在开发中可能很多参数都是固定的.
- 这个时候我们可以继续一些抽取 , 也可以利用axios的全局配置

```vue
axios.defaults.baseURL = "http://152.136.185.210:7878/api/hy66";

axios.defaults.timeout = 5000;
```

#### `为什么要进行封装`

使用封装的request网络请求,为什么进行封装,假如某一天axios突然不维护了,

我们也必须跟着更换axios,如果我们将属于axios的请求封装起来,

可以很好的将axios换成其他的网络请求工具(XHR,vue-resource)

### 4.4 如何使用拦截器 ?
axios提供了拦截器 , 用于我们在发送每次请求胡总和得到响应后 , 进行对应的处理.
如何使用拦截器呢 ?
