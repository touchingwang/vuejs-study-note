## 1.认识webpack
### 1.1 什么是webpack?
webpack是一个现代的JavaScript应用的静态模块打包工具
### 1.2 前端模块化
- 在前面学习中 , 我已经用了大量的篇幅解释了为什么前端需要模块化.
- 而且我也提到了目前使用前端模块化的一些方案:AMD, CMD, CommonJS, ES6
- 在ES6之前 , 我们要想进行模块化开发 , 就必须借助于其他的工具 , 让我们可以进行模块化开发.
- 并且在通过模块化开发完成了项目后 , 还需要处理模块间的各种依赖 , 并且将其进行整合打包.
- 而webpack其中一个核心就是让我们可以进行模块化开发, 并且会帮助我们处理模块间的依赖关系.
- 而且不仅仅是JavaScript文件 , 我们的CSS, 图片, json文件等等在webpack中都可以被当作模块来使用
- 这就是webpack中模块化的概念

打包如何理解呢?
- 理解了webpack可以帮助我们进行模块化 , 并且处理模块间的各种复杂关系后 , 打包的概念就非常好理解了.
- 就是将webpack中的各种资源模块进行打包合并成一个或多个包(Bundle)
- 并且在打包的过程中, 还可以对资源进行处理 , 比如压缩图片 , 将scss转成css , 将ES6语法转成ES5语法 , 将TypeScript转成JavaScript等等操作,
- 但是打包的操作似乎gruny/gulp也可以帮助我们完成 , 它们有什么不同呢?
## 2.webpack的安装
### 2.1 webpack安装
安装webpack首先需要安装Node.js , Node.js自带了软件包管理工具npm
查看自己的node版本

    node -v

全局安装webpack

    npm install webpack@3/6/0 -g

局部安装webpack
- --save-dev是开发时依赖 , 项目打包后不需要继续使用的.

为什么全局安装后 , 还需要局部安装呢?
- 在终端直接执行webpack命令 , 使用的全局安装的webpack
- 当在package.json中定义了script时 , 其中包含了webpack命令 , 那么使用的是局部webpack

### 2.2 js文件的打包
现在的js文件中使用了模式化的方式进行开发 , 它们可以直接使用吗? 不可以.
- 因为如果直接在index.html引用这两个js文件 , 浏览器并不识别其中的模块化代码.
- 另外 , 在真实项目中当有许多这样的js文件时 , 我们一个个引用非常麻烦 , 并且后期非常不方便对它们进行管理.

我们应该怎么做呢?使用webpack工具 , 对多个js文件进行打包.
- 使用webpack就是一个模式化的打包工具 , 所以它自持我们代码中写模块化 , 可以对模块化的代码进行处理.
- 另外 , 如果在处理完所有模块之间的关系后 , 将多个js打包到一个js文件中 , 引入时就变得非常方便了.

ok , 如何打包呢?使用webpack的指令即可

    webpack src/main.js dist/dundle.js

### 2.3 使用打包后的文件
打包后会在dist文件下 , 生成一个bundle.js文件
 - 文件内容有些复杂 , 这里暂时不先看.
 - bundle.js , 是webpack处理了项目直接文件依赖后生成的一个js文件 , 我们只需要将这个js文件在index.html中引入即可

### 2.4 准备工作
我们创建如下文件和文件夹
文件和文件夹解析:
- dist文件夹 : 用于存放之后打包的文件
- src文件夹 : 用于存放我们写的源文件
    - main.js : 项目的入口文件 . 具体内容查看下面详情.
    - mathUtils.js : 定义了一些数学工具函数 , 可以在其他地方引用 , 并且使用 . 具体内容查看下面的详情 .
- index.html : 浏览器打开展示的首页html
- package.json : 通过npm init生成的 , npm包管理的文件(暂时没有用上 , 后面才会用上)

### 2.5 入口和出口
我们考虑一下 , 如果每次使用webpack的命令都需要写上入口和出口作为参数 , 就非常麻烦 , 有没有一种方法可以将这两个参数写到配置中 , 在运行时 , 直接读取呢?
当然可以 , 就是创建一个webpack.config.js文件

```vue
const path = require('path')

module.exports = {
  //入口: 可以是字符串/数组/对象,这里我们入口只有一个,所以写一个字符串即可
  entry: './src/main.js',
  //出口: 通常是一个对象,里面至少包含两个重要属性,path和filename
  output: {
    //an absolute path需要一个全局绝对路径
    //动态的获取路径
    path: path.resolve(__dirname, 'dist'),
    filename: 'bundle.js',
  },
}
```

### 2.6 局部安装webpack
目前 , 我们使用的webpack是全局的webpack , 如果我们想使用局部来打包呢?
- 因为一个项目往往依赖特定的webpack版本 , 全局的版本可能和这个项目的webpck版本不一致 , 导致打包主线问题.
- 所以通常一个项目 , 都有自己局部的webpack

第一步 , 项目中需要安装自己的局部webpack
- 这里我们让局部安装webpack3.6.0

        npm install webpack@3.6.0 --save-dev

第二步 , 通过node modules/.bin/webpack启动webpack打包

### 2.7 package.json中定义启动
但是 , 每次执行都敲这么一长串有没有觉得不方便呢?
- OK , 我们可以在package.json的scripts中定义自己的执行脚本

package.json中的script的脚本在执行时 , 会按照一定的顺序寻找命令对应的位置.
- 首先 , 会寻找本地的node_modules/.bin路径中对应的命令
- 如果没有找到 , 会去全局的环境变量中寻找.
- 如何执行我们的build命令呢?
```vue
{
  "name": "meetwebpack",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "build": "webpack"
  },
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "webpack": "^3.6.0"
  }
}
```
        npm run build
## 3.webpack的起步



 


## 4.webpack的配置






## 5.loader的使用






## 6.plugin的使用







## 7.搭建本地服务器

